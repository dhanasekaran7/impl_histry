# ==================== src/options/option_chain_manager.py (FIXED VERSION) ====================
"""
FIXED Option Chain Manager - Resolves spot price fetching issues
Based on working nearest_expiry_test.py but with proper error handling
"""

import asyncio
import aiohttp
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
import json

logger = logging.getLogger(__name__)

class OptionChainManager:
    """
    FIXED Option Chain Manager with robust spot price fetching
    """
    
    def __init__(self, upstox_client):
        """Initialize with upstox client that has token"""
        self.upstox_client = upstox_client
        self.token = upstox_client.access_token
        self.headers = {
            'Authorization': f'Bearer {self.token}',
            'Accept': 'application/json'
        }
        self.logger = logging.getLogger(__name__)
        self._option_contracts = {}
        self._last_fetch_time = None
        self._cached_spot_price = None
        self._spot_price_cache_time = None
    
    async def get_option_chain(self, symbol: str = "NIFTY", strikes_around_atm: int = 5) -> Optional[Dict[str, Any]]:
        """
        Get option chain for nearest expiry with FIXED spot price logic
        """
        try:
            # Step 1: Get current spot price with fallback methods
            spot_price = await self._get_spot_price_robust(symbol)
            if not spot_price:
                self.logger.error("Could not fetch spot price with any method")
                return {}
            
            self.logger.info(f"âœ… Got {symbol} spot price: Rs.{spot_price:.2f}")
            
            # Step 2: Fetch nearest expiry option contracts
            contracts = await self._fetch_nearest_expiry_contracts()
            if not contracts:
                self.logger.error("Could not fetch option contracts")
                return {}
            
            # Step 3: Build option chain around ATM
            option_chain = await self._build_option_chain(
                spot_price, contracts, strikes_around_atm
            )
            
            return option_chain
            
        except Exception as e:
            self.logger.error(f"Error getting option chain: {e}")
            return {}
    
    async def _get_spot_price_robust(self, symbol: str) -> Optional[float]:
        """
        ROBUST spot price fetching with multiple fallback methods
        """
        try:
            # Method 1: Try the exact approach from working test
            spot_price = await self._get_spot_price_method1(symbol)
            if spot_price:
                self._cached_spot_price = spot_price
                self._spot_price_cache_time = datetime.now()
                return spot_price
            
            # Method 2: Try alternative instrument key format
            spot_price = await self._get_spot_price_method2(symbol)
            if spot_price:
                self._cached_spot_price = spot_price
                self._spot_price_cache_time = datetime.now()
                return spot_price
            
            # Method 3: Use cached price if recent (last 5 minutes)
            if (self._cached_spot_price and self._spot_price_cache_time and
                (datetime.now() - self._spot_price_cache_time).total_seconds() < 300):
                self.logger.warning(f"Using cached spot price: Rs.{self._cached_spot_price:.2f}")
                return self._cached_spot_price
            
            # Method 4: Emergency fallback - use market data if available
            if hasattr(self.upstox_client, 'last_market_data'):
                market_data = self.upstox_client.last_market_data
                if market_data and 'ltp' in market_data:
                    fallback_price = float(market_data['ltp'])
                    self.logger.warning(f"Using fallback spot price: Rs.{fallback_price:.2f}")
                    return fallback_price
            
            return None
            
        except Exception as e:
            self.logger.error(f"Error in robust spot price fetching: {e}")
            return None
    
    async def _get_spot_price_method1(self, symbol: str) -> Optional[float]:
        """Method 1: Exact copy from working test"""
        try:
            if symbol.upper() == "NIFTY":
                instrument_key = "NSE_INDEX|Nifty 50"
            else:
                instrument_key = f"NSE_INDEX|{symbol}"
            
            url = "https://api.upstox.com/v2/market-quote/ltp"
            params = {'instrument_key': instrument_key}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=self.headers, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get('status') == 'success':
                            quote_data = data.get('data', {})
                            
                            # Find spot price in response - exact logic from working test
                            for key, value in quote_data.items():
                                if 'Nifty' in key:  # This matches the working test
                                    spot_price = value.get('last_price')
                                    if spot_price:
                                        self.logger.debug(f"Method 1: Found {symbol} spot: Rs.{spot_price:.2f}")
                                        return float(spot_price)
                    else:
                        self.logger.debug(f"Method 1: HTTP {response.status}")
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Method 1 failed: {e}")
            return None
    
    async def _get_spot_price_method2(self, symbol: str) -> Optional[float]:
        """Method 2: Alternative approach"""
        try:
            # Try different instrument key formats
            instrument_keys = [
                f"NSE_INDEX|{symbol} 50",
                f"NSE_INDEX|{symbol}",
                f"NSE_INDEX|NIFTY 50",
                "NSE_INDEX|Nifty 50"
            ]
            
            url = "https://api.upstox.com/v2/market-quote/ltp"
            
            for instrument_key in instrument_keys:
                try:
                    params = {'instrument_key': instrument_key}
                    
                    async with aiohttp.ClientSession() as session:
                        async with session.get(url, headers=self.headers, params=params) as response:
                            if response.status == 200:
                                data = await response.json()
                                
                                if data.get('status') == 'success':
                                    quote_data = data.get('data', {})
                                    
                                    # Try to find any valid price
                                    for key, value in quote_data.items():
                                        last_price = value.get('last_price')
                                        if last_price and last_price > 20000:  # Reasonable NIFTY range
                                            self.logger.debug(f"Method 2: Found spot via {instrument_key}: Rs.{last_price:.2f}")
                                            return float(last_price)
                
                except Exception as e:
                    self.logger.debug(f"Method 2 attempt with {instrument_key} failed: {e}")
                    continue
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Method 2 failed: {e}")
            return None
    
    async def _fetch_nearest_expiry_contracts(self) -> Dict:
        """
        Fetch option contracts for nearest expiry - EXACT copy from working test
        """
        try:
            url = "https://api.upstox.com/v2/option/contract"
            params = {'instrument_key': 'NSE_INDEX|Nifty 50'}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=self.headers, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get('status') == 'success':
                            # Step 1: Collect all contracts with expiry dates
                            all_contracts = []
                            
                            for contract in data.get('data', []):
                                strike = contract.get('strike_price')
                                option_type = contract.get('instrument_type')
                                instrument_key = contract.get('instrument_key')
                                trading_symbol = contract.get('trading_symbol')
                                expiry = contract.get('expiry')
                                
                                if strike and option_type and instrument_key and expiry:
                                    # FIXED: Handle decimal strikes properly (from successful test)
                                    strike_int = int(float(strike))
                                    
                                    all_contracts.append({
                                        'strike_price': strike_int,
                                        'option_type': option_type,
                                        'instrument_key': instrument_key,
                                        'trading_symbol': trading_symbol,
                                        'expiry': expiry,
                                        'expiry_date': datetime.strptime(expiry, '%Y-%m-%d').date()
                                    })
                            
                            # Step 2: Find nearest expiry
                            expiry_dates = sorted(set(contract['expiry_date'] for contract in all_contracts))
                            nearest_expiry = expiry_dates[0]
                            
                            self.logger.info(f"Using nearest expiry: {nearest_expiry} (from {len(expiry_dates)} available)")
                            
                            # Step 3: Filter for nearest expiry only
                            contracts = {}
                            for contract in all_contracts:
                                if contract['expiry_date'] == nearest_expiry:
                                    key = f"{contract['strike_price']}{contract['option_type']}"
                                    contracts[key] = {
                                        'instrument_key': contract['instrument_key'],
                                        'strike_price': contract['strike_price'],
                                        'option_type': contract['option_type'],
                                        'trading_symbol': contract['trading_symbol'],
                                        'expiry': contract['expiry'],
                                        'expiry_date': contract['expiry_date']
                                    }
                            
                            self.logger.info(f"Loaded {len(contracts)} nearest expiry contracts")
                            return contracts
                        
                        else:
                            self.logger.error(f"API error fetching contracts: {data}")
                    else:
                        error_text = await response.text()
                        self.logger.error(f"HTTP {response.status} fetching contracts: {error_text}")
            
            return {}
            
        except Exception as e:
            self.logger.error(f"Error fetching option contracts: {e}")
            return {}
    
    async def _build_option_chain(self, spot_price: float, contracts: Dict, strikes_around_atm: int) -> Dict:
        """Build option chain around ATM strike - EXACT copy from working test"""
        try:
            # Find available strikes
            ce_strikes = sorted([int(k[:-2]) for k in contracts.keys() if k.endswith('CE')])
            
            if not ce_strikes:
                self.logger.error("No CE strikes found")
                return {}
            
            # Find ATM strike
            atm_strike = min(ce_strikes, key=lambda x: abs(x - spot_price))
            atm_index = ce_strikes.index(atm_strike)
            
            # Select strikes around ATM
            start_index = max(0, atm_index - strikes_around_atm)
            end_index = min(len(ce_strikes), atm_index + strikes_around_atm + 1)
            target_strikes = ce_strikes[start_index:end_index]
            
            self.logger.info(f"Building option chain: ATM={atm_strike}, Strikes={target_strikes}")
            
            # Build option chain with LTP
            option_chain = {
                'spot_price': spot_price,
                'atm_strike': atm_strike,
                'expiry_date': contracts[f"{atm_strike}CE"]['expiry_date'],
                'strikes': {},
                'timestamp': datetime.now().isoformat()
            }
            
            # Fetch LTP for each strike
            for strike in target_strikes:
                strike_data = {
                    'strike': strike,
                    'ce': {},
                    'pe': {}
                }
                
                # Get CE data
                ce_key = f"{strike}CE"
                if ce_key in contracts:
                    ce_contract = contracts[ce_key]
                    ce_ltp = await self._get_option_ltp(ce_contract['instrument_key'])
                    
                    strike_data['ce'] = {
                        'ltp': ce_ltp,
                        'instrument_key': ce_contract['instrument_key'],
                        'trading_symbol': ce_contract['trading_symbol'],
                        'expiry': ce_contract['expiry']
                    }
                
                # Get PE data
                pe_key = f"{strike}PE"
                if pe_key in contracts:
                    pe_contract = contracts[pe_key]
                    pe_ltp = await self._get_option_ltp(pe_contract['instrument_key'])
                    
                    strike_data['pe'] = {
                        'ltp': pe_ltp,
                        'instrument_key': pe_contract['instrument_key'],
                        'trading_symbol': pe_contract['trading_symbol'],
                        'expiry': pe_contract['expiry']
                    }
                
                option_chain['strikes'][strike] = strike_data
            
            # Count successful LTP fetches
            successful_ltps = sum(1 for strike_data in option_chain['strikes'].values() 
                                for option_data in [strike_data['ce'], strike_data['pe']] 
                                if option_data.get('ltp') is not None)
            
            self.logger.info(f"Option chain built: {len(target_strikes)} strikes, {successful_ltps} LTPs fetched")
            
            return option_chain
            
        except Exception as e:
            self.logger.error(f"Error building option chain: {e}")
            return {}
    
    async def _get_option_ltp(self, instrument_key: str) -> Optional[float]:
        """
        Get LTP for specific option instrument - EXACT copy from working test
        """
        try:
            url = "https://api.upstox.com/v2/market-quote/ltp"
            params = {'instrument_key': instrument_key}
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=self.headers, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get('status') == 'success':
                            quote_data = data.get('data', {})
                            
                            # Try different key formats (from successful test)
                            possible_keys = [
                                instrument_key,  # NSE_FO|12345
                                instrument_key.replace('|', ':'),  # NSE_FO:12345
                                instrument_key.replace('NSE_FO|', 'NSE_FO:'),  # NSE_FO:12345
                            ]
                            
                            # Try exact matches first
                            for key_format in possible_keys:
                                if key_format in quote_data:
                                    ltp = quote_data[key_format].get('last_price', 0)
                                    if ltp > 0:
                                        return float(ltp)
                            
                            # Try partial matches (handles different response formats)
                            for key in quote_data.keys():
                                if any(part in key for part in instrument_key.split('|')):
                                    ltp = quote_data[key].get('last_price', 0)
                                    if ltp > 0:
                                        return float(ltp)
                        
                        else:
                            self.logger.debug(f"API error getting LTP: {data}")
                    else:
                        self.logger.debug(f"HTTP {response.status} getting LTP for {instrument_key}")
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error getting LTP for {instrument_key}: {e}")
            return None
    
    # ADDITIONAL HELPER METHODS for the option strategy
    
    async def get_spot_price(self, symbol: str = "NIFTY") -> Optional[float]:
        """Public method to get spot price"""
        return await self._get_spot_price_robust(symbol)
    
    async def get_atm_strike(self, symbol: str = "NIFTY") -> Optional[int]:
        """Get ATM strike for the symbol"""
        try:
            spot_price = await self.get_spot_price(symbol)
            if spot_price:
                return round(spot_price / 50) * 50  # Round to nearest 50
            return None
        except Exception as e:
            self.logger.error(f"Error getting ATM strike: {e}")
            return None
    
    # Backward compatibility methods (keep existing interface)
    async def select_atm_strike(self, spot_price: float, available_strikes: List[int] = None) -> int:
        """Select ATM strike - backward compatibility"""
        if available_strikes:
            return min(available_strikes, key=lambda x: abs(x - spot_price))
        
        # If no strikes provided, calculate ATM
        return round(spot_price / 50) * 50  # Round to nearest 50
    
    async def select_itm_strike(self, spot_price: float, available_strikes: List[int] = None, 
                               option_type: str = "CE", points_itm: int = 100) -> int:
        """Select ITM strike - backward compatibility"""
        if not available_strikes:
            # Calculate ITM strike
            atm = round(spot_price / 50) * 50
            if option_type.upper() == 'CE':
                return atm - 50  # ITM for CE
            else:
                return atm + 50  # ITM for PE
        
        if option_type.upper() == 'CE':
            # For CE, ITM means strike < spot
            target_strike = spot_price - points_itm
        else:
            # For PE, ITM means strike > spot
            target_strike = spot_price + points_itm
        
        return min(available_strikes, key=lambda x: abs(x - target_strike))
    
    async def _get_nearest_expiry(self) -> str:
        """Get nearest expiry date - backward compatibility"""
        try:
            contracts = await self._fetch_nearest_expiry_contracts()
            if contracts:
                # Get any contract to extract expiry
                first_contract = next(iter(contracts.values()))
                return first_contract['expiry']
            return None
        except Exception as e:
            self.logger.error(f"Error getting nearest expiry: {e}")
            return None
